const Discord = require('discord.js');
const client = new Discord.Client();
const fs = require("fs");
const ytdl = require("ytdl-core");
const { Client, Util } = require('discord.js');
const getYoutubeID = require('get-youtube-id');
const fetchVideoInfo = require('youtube-info');
const YouTube = require('simple-youtube-api');
const youtube = new YouTube("AIzaSyAdORXg7UZUo7sePv97JyoDqtQVi3Ll0b8");
const queue = new Map();
const UserBlocked = new Set();
const prefix = '!'

client.on('ready', () => {
  console.log(`Logged in as ${client.user.tag}!`);
});
 
 
 
client.on('ready', () => {
   console.log(`----------------`);
      console.log(`Desert Bot- Script By : GMZN Host`);
        console.log(`----------------`);
      console.log(`ON ${client.guilds.size} Servers '     Script By : @ GMZN Host ' `);
    console.log(`----------------`);
  console.log(`Logged in as ${client.user.tag}!`);
client.user.setStatus("online")
 
});

//ÙƒÙˆØ¯ ØªØºÙŠØ± Ø§Ù„Ø¨Ù„Ø§ÙŠÙ†Ø¬ Ø§Ùˆ Ø§Ù„ØªÙˆÙŠØªØ´

const adminprefix = "!";//ØªØ°ÙƒÙŠØ± Ù†ØºÙŠØ± Ø§Ù„Ø¨Ø±ÙÙƒØ³
const devs = ['516576049778130954','427054141492297728'];//zÙ…Ù‡Ù… Ù†Ø­Ø· Ø§Ù„Ø§ÙŠØ¯ÙŠ
client.on('message', message => {
  var argresult = message.content.split(` `).slice(1).join(' '); //Ø­Ù‚ÙˆÙ‚ GMZN Host
    if (!devs.includes(message.author.id)) return;
   
if (message.content.startsWith(adminprefix + 'ply')) { //Ø­Ù‚ÙˆÙ‚ GMZN Host
  client.user.setGame(argresult);
    message.channel.sendMessage(`**${argresult} ØªÙ… ØªØºÙŠÙŠØ± Ø¨Ù„Ø§ÙŠÙ†Ù‚ Ø§Ù„Ø¨ÙˆØª Ø¥Ù„Ù‰ **`) //Ø­Ù‚ÙˆÙ‚ GMZN Host
} else
 
if (message.content.startsWith(adminprefix + 'tw')) {
  client.user.setGame(argresult, "https://www.twitch.tv/idk");
    message.channel.sendMessage(`**ØªÙ… ØªØºÙŠÙŠØ± ØªÙˆÙŠØªØ´ Ø§Ù„Ø¨ÙˆØª Ø¥Ù„Ù‰  ${argresult}**`) //Ø­Ù‚ÙˆÙ‚ GMZN Host
}
});

//-------------------------------------------------------------Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø³ÙˆØ±Ø³ Ø§Ù„Ø§Ø³Ø§Ø³ÙŠ--------------------------------------------------------------------------------------------------------------
 

client.on('message' , message => {
 
    if (message.content === "!inv") {
        message.reply(`ØªÙ… Ø§Ø±Ø³Ø§Ù„Ù‡ Ø§Ù„Ø±Ø§Ø¨Ø· ÙÙŠ Ø§Ù„Ø®Ø§Øµ`)
        if(!message.channel.guild) return message.reply('**Ø§Ù„Ø¢Ù…Ø± ÙÙ‚Ø· ÙÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ±Ø§Øª**');
     const embed = new Discord.RichEmbed()
 .setColor("RANDOM")
 .setThumbnail(client.user.avatarURL)    
 .setDescription("Add me" + `
 **
Ø±Ø§Ø¨Ø· Ø§Ù„Ø¨ÙˆØª |
https://discordapp.com/api/oauth2/authorize?client_id=522572942807400449&permissions=0&scope=bot
 **
`);
  message.author.sendEmbed(embed);
   }
});

//ÙƒÙˆØ¯ Ø§Ù„Ù‡ÙŠÙ„Ø¨

client.on("message", message => {
  var prefix = "*";
if (message.content === "!help") {
   message.channel.send('**ØªÙ… Ø§Ø±Ø³Ø§Ù„Ùƒ ÙÙŠ Ø§Ù„Ø®Ø§Øµ** :mailbox_with_mail: ');
const embed = new Discord.RichEmbed()
    .setDescription(`
**â•±â•±â•±â•±â•±â•±â•±â•±â•±â•±â•±â•±â•±â•±â•±
â•±â•±â”â•®â•±â•±â•±â•±â•±â•±â•±â•±â•±â•±â•±
â•±â•±â”ƒâ”ƒâ•±â•±â•±â”³â•±â”“â”³â•­â”«â”³â”“
â–‰â”â•¯â”—â”â•®â•±â”ƒâ•±â”ƒâ”£â”»â•®â”£â•±
â–‰â”ˆâ”ˆâ”ˆâ”ˆâ”ƒâ•±â”»â”›â”›â”»â•±â”»â”»â”›
â–‰â•®â”ˆâ”ˆâ”ˆâ”ƒâ•±â•±â•±â•±â•±â•±â•±â•±â•±
â•±â•°â”â”â”â•¯â•±â•±â•±â•±â•±â•±â•±â•±â•±**
** !inv ~ Ù„Ø¯Ø¹ÙˆØ© Ø§Ù„Ø¨ÙˆØª Ù„ Ø³ÙŠØ±ÙØ±Ùƒ**
** !suppport ~ Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¨ÙˆØª **
   [â–â•â•â•â•â•â•â• Ø§ÙˆØ§Ù…Ø± Ø§Ø¯Ø§Ø±ÙŠÙ‡ â•â•â•â•â•â•â•â–]
:arrow_right: ** !uchat ~ Ù„ ÙÙƒ ØªÙ‚ÙÙŠÙ„ Ø§Ù„Ø´Ø§Øª**
:arrow_right: ** !cchat ~ Ù„ ØªÙ‚ÙÙŠÙ„ Ø§Ù„Ø´Ø§Øª**
:arrow_right: ** !umute ~ Ù„ÙÙƒ Ø§Ù„Ù…ÙŠÙˆØª Ø§Ù„ÙƒØªØ§Ø¨ÙŠ**
:arrow_right: ** !mute ~ Ù„Ø¹Ù…Ù„ Ù…ÙŠÙˆØª ÙƒØªØ§Ø¨ÙŠ Ù„Ø­Ø¯**
:arrow_right: ** !send ~ Ù„ Ø¹Ù…Ù„ ØªØµÙˆÙŠØª Ø¨ Ø±ÙˆÙ… Ù…Ø­Ø¯Ø¯**
:arrow_right: ** !bc ~ Ù„ Ø§Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ù‡ Ù„Ø§Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ø³ÙŠØ±ÙØ±**
:arrow_right: ** !ban ~ Ù„ ØªØ¨Ù†ÙŠØ¯ Ø§Ø­Ø¯ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±**
:arrow_right: ** !kick ~ Ù„ Ø·Ø±Ø¯ Ø§Ø­Ø¯ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±**
:arrow_right: ** !role ~ Ù„ Ø§Ø¹Ø·Ø§Ø¡ Ø§Ø­Ø¯ Ø±ØªØ¨Ù‡**
:arrow_right: ** !ccolors ~ Ù„Ø§Ù†Ø´Ø§Ø¡ 200 Ù„ÙˆÙ† **
:arrow_right: ** !bans ~ Ù„Ù…Ø¹Ø±ÙØª Ø¹Ø¯Ø¯ Ø§Ù„Ø§Ø´Ø®Ø§Øµ Ø§Ù„Ù…ØªØ¨Ù†Ø¯ÙŠÙ† **
:arrow_right: ** !id ~ Ù„Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø­Ø³Ø§Ø¨Ùƒ **
:arrow_right: ** !clear ~ Ù„ Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ **
:arrow_right: ** !avatar ~ Ù„ Ø¹Ø±Ø¶ ØµÙˆØ±ØªÙƒ **
:arrow_right: ** !ping ~ Ù„Ù…Ø¹Ø±ÙØª Ø³Ø±Ø¹Ø© Ø§Ù„Ø¨ÙˆØª **
:arrow_right: ** !warn ~ Ù„Ø§Ø¹Ø·Ø§Ø¡ ØªØ­Ø°ÙŠØ± Ù„Ø§Ø­Ø¯ **   
   [â–â•â•â•â•â•â•â• Ù…Ø¹Ù„ÙˆÙ…Ø§Øª â•â•â•â•â•â•â•â–
:globe_with_meridians: **welcome ~ Ù„ØªØ´ØºÙŠÙ„ Ø®Ø§ØµÙŠØ© Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø§ØµÙ†Ø¹ Ø±ÙˆÙ… Ø¨Ø§Ø³Ù…**
:globe_with_meridians: **byby ~ Ù„ØªØ´ØºÙŠÙ„ Ø®Ø§ØµÙŠØ© Ø§Ù„Ù…ØºØ§Ø¯Ø±Ø© Ø§ØµÙ†Ø¹ Ø±ÙˆÙ… Ø¨Ø§Ø³Ù… **
:globe_with_meridians: **warns ~ Ø§ØµÙ†Ø¹ Ø±ÙˆÙ… Ø¨Ø§Ø³Ù… ~ !warn ~ Ù„ØªØ´ØºÙŠÙ„ Ø®Ø§ØµÙŠØ© **
:globe_with_meridians: **log ~ Ø§ØµÙ†Ø¹ Ø±ÙˆÙ… Ø¨Ø§Ø³Ù…
:globe_with_meridians: **:hammer_pick: Ø¨ÙˆØª Ù…Ø²Ø§Ù„ ØªØ­Øª ØªØ·ÙˆÙŠØ±  :tools: **
:fire: **The maker of pot: à¹–Ì¶Ì¶Ì¶Î¶ÍœÍ¡Â¤MÃ¸hÃ¡mÃªÄ‘ KhÃ¡Â£Â¥Ä‘ğŸ‘‘#3019**:fire: 
`)
 message.author.sendEmbed(embed)
 
 }
 });

//ÙƒÙˆØ¯ Ø§Ù„ÙƒÙŠÙƒ ÙˆØ§Ù„Ø¨Ø§Ù†
 
client.on('message', message => {
  if (!message.content.startsWith(prefix)) return;
 
var command = message.content.split(" ")[0];
command = command.slice(prefix.length);
 
  const args = message.content.split(" ").slice(1);
 
 
 
  if (command == "kick") {
  if(!message.channel.guild) return message.reply('**:x: Ø§Ø³Ù Ù„ÙƒÙ† Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª ÙÙ‚Ø· **');        
  if(!message.guild.member(message.author).hasPermission("KICK_MEMBERS")) return message.reply("**Ø§Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ù„ÙƒÙŠÙƒ**");
  if(!message.guild.member(client.user).hasPermission("KICK_MEMBERS")) return message.reply("**Ø§Ù„Ø¨ÙˆØª Ù„Ø§ ÙŠÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„ÙƒÙŠÙƒ");
  const user = message.mentions.users.first();
  const reason = message.content.split(" ").slice(2).join(" ");
if (message.mentions.users.size < 1) return message.reply("**Ù…Ù†Ø´Ù† Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù…Ø±Ø§Ø¯ Ø·Ø±Ø¯Ù‡**");
if (!message.guild.member(user)
.kickable) return message.reply("**Ù„Ø§ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ø·Ø±Ø¯ Ù‡Ø°Ø§ Ø§Ù„Ø´Ø®Øµ**");
 
  message.guild.member(user).kick();
 
  const kickembed = new Discord.RichEmbed()
  .setAuthor(`ØªÙ… Ø·Ø±Ø¯ Ø§Ù„Ø¹Ø¶Ùˆ`, user.displayAvatarURL)
  .setColor("#502faf")
  .setTimestamp()
  .addField("**Ø§Ù„Ø¹Ø¶Ùˆ Ø§Ù„Ù„ÙŠ Ø§Ù†Ø·Ø±Ø¯**",  '**[ ' + `${user.tag}` + ' ]**')
  .addField("**Ø§Ù„Ø¹Ø¶Ùˆ Ø§Ù„Ù„ÙŠ Ù‚Ø§Ù… Ø¨Ø§Ù„Ø·Ø±Ø¯**", '**[ ' + `${message.author.tag}` + ' ]**')
  .addField("**Ø§Ù„Ø³Ø¨Ø¨**", '**[ ' + `${reason}` + ' ]**')
  message.channel.send({
    embed : kickembed
   
  })
}
});
 
client.on('message', message => {
  if (message.author.boss) return;
  if (!message.content.startsWith(prefix)) return;
 
var command = message.content.split(" ")[0];
command = command.slice(prefix.length);
 
  const args = message.content.split(" ").slice(1);
 
  if (command == "ban") {
      if(!message.channel.guild) return message.reply('**:x: Ø§Ø³Ù Ù„ÙƒÙ† Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª ÙÙ‚Ø· **');        
  if(!message.guild.member(message.author).hasPermission("BAN_MEMBERS")) return message.reply("**Ø§Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø¨Ø§Ù†Ø¯**");
  if(!message.guild.member(client.user).hasPermission("BAN_MEMBERS")) return message.reply("Ø§Ù„Ø¨ÙˆØª Ù„Ø§ÙŠÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ø¨Ø§Ù†Ø¯");
  const user = message.mentions.users.first();
  const reason = message.content.split(" ").slice(2).join(" ");
if (message.mentions.users.size < 1) return message.reply("**Ù…Ù†Ø´Ù† Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù„ÙŠ ØªØ±ÙŠØ¯ ØªØ¨Ù†ÙŠØ¯Ù‡**");
  if (!message.guild.member(user)
.kickable) return message.reply("**Ù„Ø§ÙŠÙ…ÙƒÙ†Ù†ÙŠ ØªØ¨Ù†ÙŠØ¯ Ù‡Ø°Ø§ Ø§Ù„Ø´Ø®Øµ**");
 
  message.guild.member(user).ban();
 
  const banembed = new Discord.RichEmbed()
  .setAuthor(`ØªÙ… ØªØ¨Ù†ÙŠØ¯ Ø§Ù„Ø¹Ø¶Ùˆ`, user.displayAvatarURL)
  .setColor("#502faf")
  .setTimestamp()
  .addField("**Ø§Ù„Ø¹Ø¶Ùˆ Ø§Ù„ÙŠ ØªØ¨Ù†Ø¯:**",  '**[ ' + `${user.tag}` + ' ]**')
  .addField("**Ø§Ù„Ø¹Ø¶Ùˆ Ø§Ù„Ù„ÙŠ Ù‚Ø§Ù… Ø¨ØªØ¨Ù†ÙŠØ¯Ù‡:**", '**[ ' + `${message.author.tag}` + ' ]**')
  .addField("**Ø§Ù„Ø³Ø¨Ø¨**", '**[ ' + `${reason}` + ' ]**')
  message.channel.send({
    embed : banembed
  })
}
});

//ÙƒÙˆØ¯ Ø§Ø¹Ø·Ø§Ø¡ Ø±ØªØ¨Ù‡ Ø§Ù„Ù‡Ùˆ Ø§Ù„Ø±ÙˆÙ„
 
client.on('message', async message => {
    if(message.author.bot) return;
    if(message.channel.type === 'dm') return;
 
    var prefix = '!'; //<==== ØªÙ‚Ø¯Ø± ØªØºÙŠØ± Ø§Ù„Ø¨Ø±ÙÙƒØ³
    var args = message.content.toLowerCase().split(' ');
    var command = args[0];
    var userM = message.guild.member(message.mentions.users.first() || message.guild.members.find(m => m.id === args[1]));
 
    if(command == prefix + 'role') {
        if(!message.member.hasPermission('MANAGE_ROLES')) return message.channel.send(':no_entry: | You dont have **MANAGE_ROLES** Permission!');
        if(!message.guild.member(client.user).hasPermission('MANAGE_ROLES')) return message.channel.send(':no_entry: | I dont have **MANAGE_ROLES** Permission!');
        if(!message.guild.member(client.user).hasPermission('EMBED_LINKS')) return message.channel.send(':no_entry: | I dont have **EMBED_LINKS** Permission!');
 
        let roleCommand = new Discord.RichEmbed() // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆØ¯Ø²
        .setTitle(':white_check_mark: Role Command.')
        .setColor('GREEN')
        .setDescription(`**\n${prefix}role <SOMEONE> <ROLE>**\nâ¥ \`\`For give or delete from some one the role.\`\`\n\n**${prefix}role humans add <ROLE>**\nâ¥ \`\`For give the humans role.\`\`\n\n**${prefix}role humans remove <ROLE>**\nâ¥ \`\`For delete from the humans role.\`\`\n\n**${prefix}role bots add <ROLE>**\nâ¥ \`\`For give the bots role.\`\`\n\n**${prefix}role bots remove <ROLE>**\nâ¥ \`\`For delete from the bots role.\`\`\n\n**${prefix}role all add <ROLE>**\nâ¥ \`\`For give all role.\`\`\n\n**${prefix}role all remove <ROLE>**\nâ¥ \`\`For remove from all role.\`\``)
        .setTimestamp()
        .setFooter(message.author.tag, message.author.avatarURL)
 
        if(!args[1]) return message.channel.send(roleCommand);
        if(!userM && args[1] !== 'humans' && args[1] !== 'bots' && args[1] !== 'all') return message.channel.send(roleCommand);
 
        if(userM) {
            var argsRole = args[2];
        }else if(!userM && args[1] === 'humans' || args[1] === 'bots' || args[1] === 'all') {
            var argsRole = args[3];
        }
 
        var getRole = message.mentions.roles.first() || message.guild.roles.find(r => r.id === argsRole) || message.guild.roles.find(r => r.name.toLowerCase().includes(argsRole));
 
        if(userM) {
            if(!args[2]) return message.channel.send(`**Useage:** ${prefix}role <USER> \`\`<ROLE>\`\``);
            if(!getRole) return message.channel.send(':no_entry: | I couldn\'t find the role!');
            if(getRole.name === '@everyone') return message.channel.send(':no_entry: | I couldn\'t find the role!');
            if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`GIVE\`\` Or \`\`DELETE\`\` From any user have or not have **${getRole.name}** role beacuse this role highest from my role!`);
 
          if(message.guild.member(userM.user).roles.has(getRole.id)) {
              message.guild.member(userM.user).removeRole(getRole.id);
              message.channel.send(`:white_check_mark: | Successfully \`\`DELETE\`\` The role **${getRole.name}** From user **${userM.user.tag}**`);
          }else if(!message.guild.member(userM.user).roles.has(getRole.id)) {
              message.guild.member(userM.user).addRole(getRole.id);
              message.channel.send(`:white_check_mark: | Successfully \`\`GIVE\`\` The role **${getRole.name}** To user **${userM.user.tag}**`);
          }
      }else if(args[1] === 'humans') {
          let notArgs = new Discord.RichEmbed()
          .setTitle(':white_check_mark: Role Command.') // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆØ¯Ø²
          .setColor('GREEN')
          .setDescription(`**\n${prefix}role humans add <ROLE>**\nâ¥ \`\`For give the humans the role.\`\`\n\n**${prefix}role humans remove <ROLE>**\nâ¥ \`\`For delete the role from all humans.\`\``)
          .setTimestamp()
          .setFooter(message.author.tag, message.author.avatarURL)
 
          if(!args[2]) return message.channel.send(notArgs);
          if(!args[3]) return message.channel.send(notArgs);
          if(!getRole) return message.channel.send(':no_entry: | I couldn\'t find the role!');
            if(getRole.name === '@everyone') return message.channel.send(':no_entry: | I couldn\'t find the role!');
 
            if(args[2] === 'add') {
                if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`GIVE\`\` Any User the role with name **${getRole.name}** beacuse the role highest then my role!`);
              if(message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size == 0) return message.channel.send(`:no_entry: | I can\'t find any user not have **${getRole.name}** role!`);
 
              let humansSure = new Discord.RichEmbed()
              .setTitle(`:red_circle: Are you sure to give **${message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size}** Humans the role **${getRole.name}**`)
              .setColor('RED')
              .setDescription('**\nYou have 1 min to choose reaction you want.**\n\nâœ… = Sure, give him the role.\n\nâ = No no, cancel.')
              .setTimestamp()
              .setFooter(message.author.tag, message.author.avatarURL)
 
              message.channel.send(humansSure).then(msg => {
                  msg.react('âœ…').then(() => msg.react('â'))
 
                  let giveHim = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
                  let dontGiveHim = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id;
                  let give = msg.createReactionCollector(giveHim, { time: 60000 });
                  let dontGive = msg.createReactionCollector(dontGiveHim, { time: 60000 });
 
                  give.on('collect', r => {
                      msg.delete();
                      message.channel.send(`:timer: | Now you must wait some time to give **${message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size}** Humans the role **${getRole.name}** ...`).then(message1 => {
                          message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id) && !m.user.bot).forEach(async m => {
                              message.guild.member(m).addRole(getRole.id) // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆØ¯Ø²
                              await message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully give all **Humans** The role **${getRole.name}** .`);
                          });
                      });
                  });
                  dontGive.on('collect', r => {
                      msg.delete();
                      message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
                  });
              })
          }else if(args[2] === 'remove') {
              if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`REMOVE\`\` The role with name **${getRole.name}** From any User beacuse the role highest then my role!`);
              if(message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size == 0) return message.channel.send(`:no_entry: | I can\'t find any user have **${getRole.name}** role!`);
 
              let humansSure = new Discord.RichEmbed()
              .setTitle(`:red_circle: Are you sure to remove **${getRole.name}** from **${message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size}** Humans?`)
              .setColor('RED') // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆØ¯Ø²
              .setDescription('**\nYou have 1 min to choose reaction you want.**\n\nâœ… = Sure, remove the role from him.\n\nâ = No no, cancel.')
              .setTimestamp()
              .setFooter(message.author.tag, message.author.avatarURL)
 
              message.channel.send(humansSure).then(msg => {
                  msg.react('âœ…').then(() => msg.react('â'))
 
                  let removeRole = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
                  let dontRemoveRole = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id;
                  let remove = msg.createReactionCollector(removeRole, { time: 60000 });
                  let dontRemove = msg.createReactionCollector(dontRemoveRole, { time: 60000 });
 
                  remove.on('collect', r => {
                      msg.delete();
                      message.channel.send(`:timer: | Now you must wait some time to delete from **${message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id) && !m.user.bot).size}** Humans the role **${getRole.name}** ...`).then(message1 => {
                          message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id) && !m.user.bot).forEach(async m => {
                              message.guild.member(m).removeRole(getRole.id)
                              await message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully remove the role **${getRole.name}** From all **Humans** .`);
                          });
                      }); // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆØ¯Ø²
                  });
                  dontRemove.on('collect', r => {
                      msg.delete();
                      message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
                  });
              })
          }
      }else if(args[1] === 'bots') {
      let notArgs = new Discord.RichEmbed()
          .setTitle(':white_check_mark: Role Command.')
          .setColor('GREEN')
          .setDescription(`**\n${prefix}role bots add <ROLE>**\nâ¥ \`\`For give the bots the role.\`\`\n\n**${prefix}role bots remove <ROLE>**\nâ¥ \`\`For delete the role from all bots.\`\``)
          .setTimestamp()
          .setFooter(message.author.tag, message.author.avatarURL)
 
          if(!args[2]) return message.channel.send(notArgs);
          if(!args[3]) return message.channel.send(notArgs); // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆØ¯Ø²
          if(!getRole) return message.channel.send(':no_entry: | I couldn\'t find the role!');
            if(getRole.name === '@everyone') return message.channel.send(':no_entry: | I couldn\'t find the role!');
 
            if(args[2] === 'add') {
                if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`GIVE\`\` Any Bot the role with name **${getRole.name}** beacuse the role highest then my role!`);
              if(message.guild.members.filter(b => !message.guild.member(b).roles.has(getRole.id) && b.user.bot).size == 0) return message.channel.send(`:no_entry: | I can\'t find any bot not have **${getRole.name}** role!`);
 
              let botsSure = new Discord.RichEmbed()
              .setTitle(`:red_circle: Are you sure to give **${message.guild.members.filter(b => !message.guild.member(b).roles.has(getRole.id) && b.user.bot).size}** Bots the role **${getRole.name}**`)
              .setColor('RED')
              .setDescription('**\nYou have 1 min to choose reaction you want.**\n\nâœ… = Sure, give him the role.\n\nâ = No no, cancel.')
              .setTimestamp()
              .setFooter(message.author.tag, message.author.avatarURL)
 
              message.channel.send(botsSure).then(msg => {
                  msg.react('âœ…').then(() => msg.react('â'))
 
                  let giveHim = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
                  let dontGiveHim = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id;
                  let give = msg.createReactionCollector(giveHim, { time: 60000 });
                  let dontGive = msg.createReactionCollector(dontGiveHim, { time: 60000 }); // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆØ¯Ø²
 
                  give.on('collect', r => {
                      msg.delete();
                      message.channel.send(`:timer: | Now you must wait some time to give **${message.guild.members.filter(b => !message.guild.member(b).roles.has(getRole.id) && b.user.bot).size}** Bots the role **${getRole.name}**...`).then(message1 => {
                          message.guild.members.filter(b => !message.guild.member(b).roles.has(getRole.id) && b.user.bot).forEach(async b => {
                              message.guild.member(b).addRole(getRole.id)
                              await message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully give all **Bots** The role **${getRole.name}** .`);
                          });
                      });
                  });
                  dontGive.on('collect', r => {
                      msg.delete();
                      message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
                  }); // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆØ¯Ø²
              })
          }else if(args[2] === 'remove') {
              if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`REMOVE\`\` The role with name **${getRole.name}** From any Bot beacuse the role highest then my role!`);
              if(message.guild.members.filter(b => message.guild.member(b).roles.has(getRole.id) && b.user.bot).size == 0) return message.channel.send(`:no_entry: | I can\'t find any bot have **${getRole.name}** role!`);
 
              let humansSure = new Discord.RichEmbed()
              .setTitle(`:red_circle: Are you sure to remove **${getRole.name}** from **${message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id) && m.user.bot).size}** Bots?`)
              .setColor('RED')
              .setDescription('**\nYou have 1 min to choose reaction you want.**\n\nâœ… = Sure, remove the role from him.\n\nâ = No no, cancel.')
              .setTimestamp()
              .setFooter(message.author.tag, message.author.avatarURL)
 
              message.channel.send(humansSure).then(msg => {
                  msg.react('âœ…').then(() => msg.react('â')) // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆØ¯Ø²
 
                  let removeRole = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
                  let dontRemoveRole = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id;
                  let remove = msg.createReactionCollector(removeRole, { time: 60000 });
                  let dontRemove = msg.createReactionCollector(dontRemoveRole, { time: 60000 });
 
                  remove.on('collect', r => {
                      msg.delete();
                      message.channel.send(`:timer: | Now you must wait some time to delete from **${message.guild.members.filter(b => message.guild.member(b).roles.has(getRole.id) && b.user.bot).size}** Bots the role **${getRole.name}**...`).then(message1 => {
                          message.guild.members.filter(b => message.guild.member(b).roles.has(getRole.id) && b.user.bot).forEach(async b => {
                              message.guild.member(b).removeRole(getRole.id)
                              await message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully remove the role **${getRole.name}** From all **Bots** .`);
                          });
                      });
                  });
                  dontRemove.on('collect', r => { // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆØ¯Ø²
                      msg.delete();
                      message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
                  });
              })
          }
      }else if(args[1] === 'all') {
          let notArgs = new Discord.RichEmbed()
          .setTitle(':white_check_mark: Role Command.')
          .setColor('GREEN') // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆØ¯Ø²
          .setDescription(`**\n${prefix}role all add <ROLE>**\nâ¥ \`\`For give all the role.\`\`\n\n**${prefix}role all remove <ROLE>**\nâ¥ \`\`For delete the role from all.\`\``)
          .setTimestamp()
          .setFooter(message.author.tag, message.author.avatarURL)
 
          if(!args[2]) return message.channel.send(notArgs);
          if(!args[3]) return message.channel.send(notArgs);
          if(!getRole) return message.channel.send(':no_entry: | I couldn\'t find the role!');
            if(getRole.name === '@everyone') return message.channel.send(':no_entry: | I couldn\'t find the role!');
 
            if(args[2] === 'add') {
                if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`GIVE\`\` Any User the role with name **${getRole.name}** beacuse the role highest then my role!`);
              if(message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id)).size == 0) return message.channel.send(`:no_entry: | I can\'t find any user not have **${getRole.name}** role!`);
 
              let allSure = new Discord.RichEmbed()
              .setTitle(`:red_circle: Are you sure to give **${message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id)).size}** The role **${getRole.name}** ?`)
              .setColor('RED')
              .setDescription('**\nYou have 1 min to choose reaction you want.**\n\nâœ… = Sure, give all the role.\n\nâ = No no, cancel.')
              .setTimestamp()
              .setFooter(message.author.tag, message.author.avatarURL)
 
              message.channel.send(allSure).then(msg => {
                  msg.react('âœ…').then(() => msg.react('â'))
 
                  let giveAll = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
                  let dontGiveAll = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id;
                  let give = msg.createReactionCollector(giveAll, { time: 60000 });
                  let dontGive = msg.createReactionCollector(dontGiveAll, { time: 60000 });
// Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆØ¯Ø²
                  give.on('collect', r => {
                      msg.delete();
                      message.channel.send(`:timer: | Now you must wait some time to give **${message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id)).size}** The role **${getRole.name}** ...`).then(message1 => {
                          message.guild.members.filter(m => !message.guild.member(m).roles.has(getRole.id)).forEach(async m => {
                              message.guild.member(m).addRole(getRole.id)
                              await message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully give **All** The role **${getRole.name}** .`);
                          });
                      });
                  });
                  dontGive.on('collect', r => {
                      msg.delete();
                      message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
                  });
              })
          }else if(args[2] === 'remove') {
              if(getRole.position >= message.guild.member(client.user).highestRole.position) return message.channel.send(`:no_entry: | I can\'t \`\`REMOVE\`\` The role with name **${getRole.name}** From any User beacuse the role highest then my role!`);
              if(message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id)).size == 0) return message.channel.send(`:no_entry: | I can\'t find any user have **${getRole.name}** role!`);
 
              let allSure = new Discord.RichEmbed()
              .setTitle(`:red_circle: Are you sure to remove **${getRole.name}** from **${message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id)).size}** ?`)
              .setColor('RED')
              .setDescription('**\nYou have 1 min to choose reaction you want.**\n\nâœ… = Sure, remove the role from him.\n\nâ = No no, cancel.')
              .setTimestamp()
              .setFooter(message.author.tag, message.author.avatarURL)
 
              message.channel.send(allSure).then(msg => {
                  msg.react('âœ…').then(() => msg.react('â')) // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆØ¯Ø²
 
                  let removeRole = (reaction, user) => reaction.emoji.name === 'âœ…'  && user.id === message.author.id;
                  let dontRemoveRole = (reaction, user) => reaction.emoji.name === 'â' && user.id === message.author.id;
                  let remove = msg.createReactionCollector(removeRole, { time: 60000 });
                  let dontRemove = msg.createReactionCollector(dontRemoveRole, { time: 60000 });
 
                  remove.on('collect', r => {
                      msg.delete();
                      message.channel.send(`:timer: | Now you must wait some time to delete from **${message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id)).size}** The role **${getRole.name}** ...`).then(message1 => {
                          message.guild.members.filter(m => message.guild.member(m).roles.has(getRole.id)).forEach(async m => {
                              message.guild.member(m).removeRole(getRole.id);
                              await message1.edit(`:white_check_mark: | <@${message.author.id}> Successfully remove the role **${getRole.name}** From **All** .`);
                          });
                      }); // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆØ¯Ø²
                  });
                  dontRemove.on('collect', r => {
                      msg.delete();
                      message.channel.send(':negative_squared_cross_mark: | The command has been canceld.').then(msg => msg.delete(5000));
                  });
              })
          } // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆØ¯Ø²
      }
  } // Ø­Ù‚ÙˆÙ‚ Ø§Ù„ÙØ§ ÙƒÙˆØ¯Ø²
});

//ÙƒÙˆØ¯ Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ø¨ ØµÙˆØ±Ù‡
 
client.on('guildMemberAdd', Sal => { //By Salto7#4595
    var embed = new Discord.RichEmbed()
    .setAuthor(Sal.user.username, Sal.user.avatarURL)
    .setThumbnail(Sal.user.avatarURL)
    .setImage('http://live-timely-4jepdssgmc.time.ly/wp-content/uploads/2018/08/welcomeEvents.jpg') //Ù‡Ù†Ø§ Ø­Ø· Ø§Ù„ØµÙˆØ±Ù‡ Ø§Ù„ÙŠ ØªØ¨ÙŠÙ‡Ø§
    .setTitle('Ø¹Ø¶Ùˆ Ø¬Ø¯ÙŠØ¯!')
    .setDescription('Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ±')
    .addField('``Ø§ÙŠØ¯ÙŠ Ø§Ù„Ø¹Ø¶Ùˆ``:',"" +  Sal.user.id, true)
    .addField('``ØªØ§Ù‚ Ø§Ù„Ø¹Ø¶Ùˆ``', Sal.user.discriminator, true)
    .addField('``ØªÙ… Ø§Ù„Ø§Ù†Ø´Ø§Ø¡ ÙÙŠ``', Sal.user.createdAt, true)
    .addField(' ğŸ‘¤  Ø§Ù†Øª Ø±Ù‚Ù…',`**[ ${Sal.guild.memberCount} ]**`,true)
    .setColor('RANDOM')
    .setFooter(Sal.guild.name, Sal.guild.iconURL, true)
    var channel =Sal.guild.channels.find('welcome', 'name') //zÙ‡Ù†Ø§ Ø­Ø· Ø§Ø³Ù… Ø§Ù„Ø±ÙˆÙ… Ø§Ù„ÙŠ ØªØ¨ÙŠÙ‡ ÙŠÙƒØªØ¨ ÙÙŠÙ‡
    if (!channel) return;
    channel.send({embed : embed});
    });

//ÙƒÙˆØ¯ Ø§Ù„Ù…ÙŠÙˆØª ÙˆÙÙƒ Ø§Ù„Ù…ÙŠÙˆØª
 
client.on('message', message => {  
if (message.author.boss) return;
var prefix = "!";
if (!message.content.startsWith(prefix)) return;
let command = message.content.split(" ")[0];
command = command.slice(prefix.length);
let args = message.content.split(" ").slice(1);
if (command == "mute") {
if (!message.channel.guild) return;
if(!message.guild.member(message.author).hasPermission("MANAGE_MESSAGES")) return message.reply("Ø§Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ§Øª !! ").then(msg => msg.delete(5000));
if(!message.guild.member(client.user).hasPermission("MANAGE_MESSAGES")) return message.reply("Ø§Ù„Ø¨ÙˆØª Ù„Ø§ÙŠÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ§Øª ").then(msg => msg.delete(5000));;
let user = message.mentions.users.first();
let muteRole = message.guild.roles.find("name", "Muted");
if (!muteRole) return message.reply("** Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±ØªØ¨Ø© Ø§Ù„Ù…ÙŠÙˆØª 'Muted' **").then(msg => {msg.delete(5000)});
if (message.mentions.users.size < 1) return message.reply('** ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ù…Ù†Ø´Ù† Ø§ÙˆÙ„Ø§Ù‹ **').then(msg => {msg.delete(5000)});
let reason = message.content.split(" ").slice(2).join(" ");
message.guild.member(user).addRole(muteRole);
const muteembed = new Discord.RichEmbed()
.setColor("RANDOM")
.setAuthor(`Muted!`, user.displayAvatarURL)
.setThumbnail(user.displayAvatarURL)
.addField("**:busts_in_silhouette:  Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…**",  '**[ ' + `${user.tag}` + ' ]**',true)
.addField("**:hammer:  ØªÙ… Ø¨ÙˆØ§Ø³Ø·Ø© **", '**[ ' + `${message.author.tag}` + ' ]**',true)
.addField("**:book:  Ø§Ù„Ø³Ø¨Ø¨**", '**[ ' + `${reason}` + ' ]**',true)
.addField("User", user, true)  
message.channel.send({embed : muteembed});
var muteembeddm = new Discord.RichEmbed()
.setAuthor(`Muted!`, user.displayAvatarURL)
.setDescription(`
${user} Ø§Ù†Øª Ù…Ø¹Ø§Ù‚Ø¨ Ø¨Ù…ÙŠÙˆØª ÙƒØªØ§Ø¨ÙŠ Ø¨Ø³Ø¨Ø¨ Ù…Ø®Ø§Ù„ÙØ© Ø§Ù„Ù‚ÙˆØ§Ù†ÙŠÙ†
 
 ${message.author.tag} ØªÙ…Øª Ù…Ø¹Ø§Ù‚Ø¨ØªÙƒ Ø¨ÙˆØ§Ø³Ø·Ø©
 
[ ${reason} ] : Ø§Ù„Ø³Ø¨Ø¨
 
Ø§Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¹Ù‚ÙˆØ¨Ø© Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ø®Ø·Ø£ ØªÙƒÙ„Ù… Ù…Ø¹ Ø§Ù„Ù…Ø³Ø¤Ù„ÙŠÙ†
`)
.setFooter(`ÙÙŠ Ø³ÙŠØ±ÙØ± : ${message.guild.name}`)
.setColor("RANDOM")
 user.send( muteembeddm);
}
if (command == "unmute") {
if (!message.channel.guild) return;
if(!message.guild.member(message.author).hasPermission("MANAGE_MESSAGES")) return message.reply("Ø§Ù†ØªØ§ Ù„Ø§ ØªÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ§Øª").then(msg => msg.delete(5000));
if(!message.guild.member(client.user).hasPermission("MANAGE_MESSAGES")) return message.reply("Ø§Ù„Ø¨ÙˆØª Ù„Ø§ÙŠÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ§Øª ").then(msg => msg.delete(5000));;
let user = message.mentions.users.first();
let muteRole = message.guild.roles.find("name", "Muted");
if (!muteRole) return message.reply("** Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±ØªØ¨Ø© Ø§Ù„Ù…ÙŠÙˆØª 'Muted' **").then(msg => {msg.delete(5000)});
if (message.mentions.users.size < 1) return message.reply('** ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ù…Ù†Ø´Ù† Ø§ÙˆÙ„Ø§Ù‹ **').then(msg => {msg.delete(5000)});
let reason = message.content.split(" ").slice(2).join(" ");
message.guild.member(user).removeRole(muteRole);
const unmuteembed = new Discord.RichEmbed()
.setColor("RANDOM")
.setAuthor(`UnMute!`, user.displayAvatarURL)
.setThumbnail(user.displayAvatarURL)
.addField("**:busts_in_silhouette:  Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…**",  '**[ ' + `${user.tag}` + ' ]**',true)
.addField("**:hammer:  ØªÙ… Ø¨ÙˆØ§Ø³Ø·Ø© **", '**[ ' + `${message.author.tag}` + ' ]**',true)
.addField("**:book:  Ø§Ù„Ø³Ø¨Ø¨**", '**[ ' + `${reason}` + ' ]**',true)
.addField("User", user, true)  
message.channel.send({embed : unmuteembed}).then(msg => msg.delete(5000));
var unmuteembeddm = new Discord.RichEmbed()
.setDescription(`ØªÙ… ÙÙƒ Ø§Ù„Ù…ÙŠÙˆØª Ø¹Ù†Ùƒ ${user}`)
.setAuthor(`UnMute!`, user.displayAvatarURL)
.setColor("RANDOM")
  user.send( unmuteembeddm);
}
});


//ÙƒÙˆØ¯ Ø§Ù…Ø± Ø¹Ù…Ù„ ØªØµÙˆÙŠØª Ù…Ù† Ø§Ù„Ø¨ÙˆØª ÙÙŠ Ø±ÙˆÙ… Ù…Ø®ØµØµ
 
client.on('message' , message => {
  var prefix = "!";
  if(message.author.bot) return;
  if(message.content.startsWith(prefix + "send")) {
  if(!message.member.hasPermission('ADMINISTRATOR')) return      message.channel.send('**Ù„Ù„Ø£Ø³Ù Ù„Ø§ ØªÙ…ØªÙ„Ùƒ ØµÙ„Ø§Ø­ÙŠØ©** `ADMINISTRATOR`' );
    let args = message.content.split(" ").slice(1);
 
 
    let suggestmessage = args.join(" ").slice(22);
    let suggestchannel = message.mentions.channels.first();
 
    if (!suggestchannel) {
        return message.reply("Ø¨Ø±Ø¬Ø§Ø¡ Ø¹Ù…Ù„ Ù…Ù†Ø´Ù† Ù„Ù„Ø±ÙˆÙ…")
    }
 
    if (!suggestmessage) {
        return message.reply("Ø¨Ø±Ø¬Ø§Ø¡ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ù†Øµ Ø§Ù„ÙƒØªØ§Ø¨ÙŠ Ø§Ù„Ø°ÙŠ Ø³ÙŠØ±Ø³Ù„ Ù„Ù„Ø±ÙˆÙ…")
   
         
    }
     message.delete();
suggestchannel.send("@everyone || @here ");
    let embed = new Discord.RichEmbed()
        .addField("**ØªØµÙˆÙŠØª Ø¹Ø§Ù… Ù„Ù„Ø¬Ù…ÙŠØ¹**", `${suggestmessage}`)
        .setFooter(`by ${message.author.tag}`)
        .setTimestamp()
    suggestchannel.send({
        embed
    }).then(msg => {
        msg.react("âœ…").then(r => msg.react("â"))
    });
 
 
    message.reply(`Your message is sended.`).then(msg => msg.delete(1000));
    return;
}
});

//ÙƒÙˆØ¯ ØªÙ‚ÙÙŠÙ„ Ø§Ù„Ø´Ø§Øª ÙˆÙØªØ­Ùˆ
 
client.on('message', message => {
 
    if (message.content === "!cchat") {
                        if(!message.channel.guild) return message.reply(' Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙÙ‚Ø· Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª !!');
 
if(!message.member.hasPermission('MANAGE_MESSAGES')) return message.reply(' Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª');
           message.channel.overwritePermissions(message.guild.id, {
         SEND_MESSAGES: false
 
           }).then(() => {
               message.reply("ØªÙ… ØªÙ‚ÙÙŠÙ„ Ø§Ù„Ø´Ø§Øª âœ… ")
           });
             }
if (message.content === "!uchat") {
    if(!message.channel.guild) return message.reply(' Ù‡Ø°Ø§ Ø§Ù„Ø§Ù…Ø± ÙÙ‚Ø· Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª !!');
 
if(!message.member.hasPermission('MANAGE_MESSAGES')) return message.reply('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª');
           message.channel.overwritePermissions(message.guild.id, {
         SEND_MESSAGES: true
 
           }).then(() => {
               message.reply("ØªÙ… ÙØªØ­ Ø§Ù„Ø´Ø§Øªâœ…")
           });
             }
 
 
 
});


//Ø«Ø§Ù†ÙŠ ÙƒÙˆØ¯ Ù…Ø¹Ù†Ø§ Ù‡ÙˆØ§ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª Ø§Ù„Ø¨Ø´ÙƒÙ„ Ø¬Ù…ÙŠÙ„
 
client.on('message', message => {
        var prefix = "!";
              if(!message.channel.guild) return;
    if(message.content.startsWith(prefix + 'bc')) {
    if(!message.channel.guild) return message.channel.send('**Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± ÙÙ‚Ø· Ù„Ù„Ø³ÙŠØ±ÙØ±Ø§Øª**').then(m => m.delete(5000));
  if(!message.member.hasPermission('ADMINISTRATOR')) return      message.channel.send('**Ù„Ù„Ø£Ø³Ù Ù„Ø§ ØªÙ…ØªÙ„Ùƒ ØµÙ„Ø§Ø­ÙŠØ©** `ADMINISTRATOR`' );
    let args = message.content.split(" ").join(" ").slice(2 + prefix.length);
    let copy = "Ã‰L JÃ˜KÃŠR ğŸ‘‘";
    let request = `Requested By ${message.author.username}`;
    if (!args) return message.reply('**ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ ÙƒØªØ§Ø¨Ø© ÙƒÙ„Ù…Ø© Ø§Ùˆ Ø¬Ù…Ù„Ø© Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª**');message.channel.send(`**Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø±Ø³Ø§Ù„Ùƒ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³ØªØŸ \nÙ…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¨Ø±ÙˆØ¯ÙƒØ§Ø³Øª:** \` ${args}\``).then(msg => {
    msg.react('âœ…')
    .then(() => msg.react('âŒ'))
    .then(() =>msg.react('âœ…'))
    
    let reaction1Filter = (reaction, user) => reaction.emoji.name === 'âœ…' && user.id === message.author.id;
    let reaction2Filter = (reaction, user) => reaction.emoji.name === 'âŒ' && user.id === message.author.id;
    
    let reaction1 = msg.createReactionCollector(reaction1Filter, { time: 12000 });
    let reaction2 = msg.createReactionCollector(reaction2Filter, { time: 12000 });
 reaction1.on("collect", r => {
    message.channel.send(`**â˜‘ | Done ... The Broadcast Message Has Been Sent For __${message.guild.members.size}__ Members**`).then(m => m.delete(5000));
    message.guild.members.forEach(m => {
 var bc = new
       Discord.RichEmbed()
       .setColor('RANDOM')
       .setTitle('Broadcast')
       .addField(':tulip: Ø³ÙŠØ±ÙØ±', message.guild.name)
       .addField(':crown: Ø§Ù„Ù…Ø±Ø³Ù„', message.author.username)
       .addField(':arrow_forward: Ø§Ù„Ø±Ø³Ø§Ù„Ø©', args)
       .setThumbnail(message.author.avatarURL)
       .setFooter(copy, client.user.avatarURL);
    m.send({ embed: bc })
    msg.delete();
    })
    })
    reaction2.on("collect", r => {
    message.channel.send(`**Broadcast Canceled.**`).then(m => m.delete(5000));
    msg.delete();
    })
    })
    }
    });

client.on("guildMemberAdd", member => {
  member.createDM().then(function (channel) {
  return channel.send(`:hearts:Ù…Ù†ÙˆØ± Ø§Ù„Ø³ÙŠØ±ÙØ±:hearts:
:crown:Ø§Ø³Ù…Ùƒ:crown: : ${member}  
Ø£Ù†Øª Ø§Ù„Ø¹Ø¶Ùˆ Ø±Ù‚Ù…: : ${member.guild.memberCount} `) 
}).catch(console.error)
})

client.on('guildMemberRemove', Sal => { //By Salto7#4595
  var embed = new Discord.RichEmbed()
  .setAuthor(Sal.user.username, Sal.user.avatarURL)
  .setThumbnail(Sal.user.avatarURL)
  .setImage('https://cdn.discordapp.com/attachments/505491202871787521/509701858571321350/download.jpg') //Ù‡Ù†Ø§ Ø­Ø· Ø§Ù„ØµÙˆØ±Ù‡ Ø§Ù„ÙŠ ØªØ¨ÙŠÙ‡Ø§
  .setTitle('Ø®Ø±Ø¬ Ø¹Ø¶Ùˆ')
  .setDescription('Ø§Ù„Ù„Ù‡ Ù…Ø¹Ùƒ Ù…Ø¹ Ø§Ù„Ø³Ù„Ø§Ù…Ù‡')
  .addField('``Ø§ÙŠØ¯ÙŠ Ø§Ù„Ø¹Ø¶Ùˆ``:',"" +  Sal.user.id, true)
  .addField('``ØªØ§Ù‚ Ø§Ù„Ø¹Ø¶Ùˆ``', Sal.user.discriminator, true)
  .addField('``ØªÙ… Ø§Ù„Ø§Ù†Ø´Ø§Ø¡ ÙÙŠ``', Sal.user.createdAt, true)
  .addField(' ?? Ø§Ù„Ø§Ù† ',`**[ ${Sal.guild.memberCount} ]**`,true)
  .setColor('RED')
  .setFooter(Sal.guild.name, Sal.guild.iconURL, true)
  var channel =Sal.guild.channels.find('name', 'byby') // Ù‡Ù†Ø§ Ø­Ø· Ø§Ø³Ù… Ø§Ù„Ø±ÙˆÙ… Ø§Ù„ÙŠ ØªØ¨ÙŠÙ‡ ÙŠÙƒØªØ¨ ÙÙŠÙ‡
  if (!channel) return;
  channel.send({embed : embed});
  });

client.on('guildCreate', guild => {
  var embed = new Discord.RichEmbed()
  .setColor(0x5500ff)
  .setDescription('Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ Ù„Ø¥Ø¶Ø§ÙÙ‡ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ù‰ Ø³ÙŠØ±ÙØ±Ùƒ')
      guild.owner.send(embed)
});


client.on('message', message=> {
    if (message.author.bot) return;
    if (message.isMentioned(client.user))
    {
    message.reply("Ù‡Ù„Ø§ Ø§Ù…Ø±Ù†ÙŠ Ø§Ø°Ø§ ØªØ¨ÙŠ Ù…Ø³Ø§Ø¹Ø¯Ù‡ Ø§ÙƒØªØ¨ !help");
    }
});

client.on('message', function(message) {
    if(!message.channel.guild) return;
    if(message.content === '!ccolors') {
    if(message.member.hasPermission('MANAGE_ROLES')) {
    setInterval(function(){})
    message.channel.send('ÙŠØªÙ… Ø§Ù†Ø´Ø§Ø¡ 200 Ù„ÙˆÙ† Ø§Ù†ØªØ¶Ø± | ')
    }else{
    message.channel.send('Ù…Ø§ Ù…Ø¹Ø§Ùƒ Ø§Ù„Ø¨Ø±Ù…Ø´Ù† Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ |')
    }
    }
    });
    
    client.on('message', message=>{
    if (message.content === '!ccolors'){
    if(!message.channel.guild) return;
    if (message.member.hasPermission('MANAGE_ROLES')){
    setInterval(function(){})
    let count = 0;
    let ecount = 0;
    for(let x = 1; x < 200; x++){
    message.guild.createRole({name:x,
    color: 'RANDOM'})
    }
    }
    }
    });

client.on('message', message => {
    if (message.content.startsWith("!bans")) {
     if(!message.guild.member(message.author).hasPermission("BAN_MEMBERS")) return message.reply("**Ø§Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø¨Ø§Ù†Ø¯**");


        message.guild.fetchBans()
        .then(bans => message.channel.send(`${bans.size} Ø¹Ø¯Ø¯ Ø§Ø´Ø®Ø§Øµ Ø§Ù„Ù…Ø¨Ù†Ø¯Ø© Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ± `))
  .catch(console.error);
}
});

client.on('message', msg => {
  if (msg.content === 'Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…') {
    msg.reply('ÙˆØ¹Ù„ÙŠÙƒÙ… Ø§Ù„Ø³Ù„Ø§Ù… ÙˆØ±Ø­Ù…Ø© Ø§Ù„Ù„Ù‡ ØªØ¹Ø§Ù„Ù‰ ÙˆØ¨Ø±ÙƒØ§ØªÙ‡ :heart:');
  }
});


client.on('message', msg => {
  if (msg.content === 'Ø¨Ø§Ùƒ') {
    msg.reply('Welcome Back  :heartpulse: ');
  }
});


client.on('message', msg => {
  if (msg.content === 'Ù‡Ù„Ø§') {
    msg.reply(':heart:Ù‡Ù„Ø§Ø¨ÙŠÙƒ ÙŠØ§Ø¹Ù…Ø±ÙŠ Ù…Ù†ÙˆØ±Ù†Ø§:heart:');
  }
});

client.on('message', msg => {
  if (msg.content === 'Ø¨Ø§ÙŠ') {
    msg.reply(':heart: Ø¨Ø§ÙŠ ÙŠØ§ Ø­Ø¨ :heart:');
  }
});

client.on('message', msg => {
  if (msg.content === 'Ø§Ø­Ø§') {
    msg.reply(':rage:Ø¹ÙŠØ¨ Ø§Ù†ØªØ§ ÙƒØ¨ÙŠØ±:rage:');
  }
});

client.on('message', msg => {
  if (msg.content === 'Ø®Ø®') {
    msg.reply(':rage:Ø¹ÙŠØ¨ Ø§Ù†ØªØ§ ÙƒØ¨ÙŠØ±:rage:');
  }
});


client.on('message', msg => {
  if (msg.content === 'Ù†ÙˆØ¨') {
    msg.reply('Ø´Ø¨Ù‡Ùƒ :innocent::joy:');
  }
});

client.on('typingStart', (ch, user) => {
    if(user.presence.status === 'offline') {
        ch.send(`${user} ØªØ­Ø°ÙŠØ± Ù‡Ø°Ø§ Ø´Ø®Øµ Ù…Ø³ÙˆÙŠ Ù†ÙØ³Ù‡ Ø§ÙˆÙ Ù„Ø§ÙŠÙ† ÙˆÙŠÙƒØªØ¨`)
        .then(msg => {
            msg.delete(10000)
        })
    }
});

    client.on('message', message => {
     if (message.content === "!id") {
     let embed = new Discord.RichEmbed()
  .setThumbnail(message.author.avatarURL)  
  .setAuthor(message.author.username)
.setDescription("Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø§Ù„Ø­Ù€Ù€Ø³Ø§Ø¨")
               .setFooter(`EL JOKER.`, '')
  .setColor("#9B59B6")
  .addField("Ø§Ø³Ù€Ù€Ù€Ù… Ø§Ù„Ø­Ø³Ù€Ù€Ø§Ø¨", `${message.author.username}`)
  .addField('ÙƒÙˆØ¯ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®Ø§Øµ', message.author.discriminator)
  .addField("Ø§Ù„Ø±Ù‚Ù€Ù€Ù€Ù… Ø§Ù„Ø´Ù€Ù€Ù€Ø®ØµÙŠ", message.author.id)
  .addField('Ø¨Ù€Ù€Ù€Ù€ÙˆØª', message.author.bot)
  .addField("ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØ³Ø¬ÙŠÙ„", message.author.createdAt)
     
     
  message.channel.sendEmbed(embed);
    }
});

client.on('message', msg => {
  if (msg.content === '!suppport') {
    msg.reply('Ø§Ù„Ø³ÙŠØ±ÙØ± Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ù‡,https://discord.gg/pP6FEA');
  }
});

client.on('message', message => {
    var args = message.content.split(/[ ]+/)
    if(message.content.includes('discord.gg')){
      if(!message.member.hasPermission('ADMINISTRATOR'))
        message.delete()
    return message.reply(`** No Invite Links :angry: ! **`)
    }
});

client.on('message', message => {
  if(message.content === ('!clear')) {
  let modRole = message.guild.roles.find("name", "Admin");
  if (!modRole) return message.reply('You do not have Admin Role'); {
    }
  const params = message.content.split(" ").slice(1)
    let messagecount = parseInt(params[0]);
    message.channel.fetchMessages({limit: messagecount})
        .then(messages => message.channel.bulkDelete(messages));
  }
});

client.on("message", message => {
    var prefix = "!";
 
            var args = message.content.substring(prefix.length).split(" ");
            if (message.content.startsWith(prefix + "clear")) {
   if(!message.member.hasPermission('MANAGE_MESSAGES')) return message.reply('? | **Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª**');
        var msg;
        msg = parseInt();
      
      message.channel.fetchMessages({limit: msg}).then(messages => message.channel.bulkDelete(messages)).catch(console.error);
      message.channel.sendMessage("", {embed: {
        title: "Done | ØªÙ€Ù€Ù…",
        color: 0x06DF00,
        description: "ØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø¨Ù†Ø¬Ø§Ø­",
        footer: {
          text: "EL JOKER."
        }
      }}).then(msg => {msg.delete(3000)});
                          }

     
});

client.on('message', message => {
    if (message.content === "!avatar") {
    message.reply(message.author.avatarURL); 
    }
});

client.on("message", message => {
      if (message.content === "!ping") {
      const embed = new Discord.RichEmbed()
  .setColor("RANDOM")
  .addField('**Ping:**' , `${Date.now() - message.createdTimestamp}` + ' ms')
  message.channel.sendEmbed(embed);
    }
});

 client.on('message', msg => {
    if (msg.content.startsWith(`!warn`)) {
       let args = msg.content.split(" ").slice(1);
      if (!msg.mentions.members.first()) return msg.reply('Ù…Ù†Ø´Ù† Ø§Ù„Ø´Ø®Øµ Ø§Ù„Ù…Ø­Ø¯Ø¯')
      if (!args[1]) return msg.reply('``Ø§ÙƒØªØ¨ Ø§Ù„Ø³Ø¨Ø¨``')
      //ØºÙŠØ± Ø§Ø³Ù… Ø§Ù„Ø±ÙˆÙ… Ø§Ùˆ Ø³ÙˆÙŠ Ø±ÙˆÙ… Ø¨Ø°Ø§ Ø§Ù„Ø§Ø³Ù…
      if (msg.guild.channels.find('name', 'warns')) {
        //Ø§Ø°Ø§ ØºÙŠØ±Øª ÙÙˆÙ‚ ØºÙŠØ± Ù‡Ù†Ø§ ÙƒÙ…Ø§Ù†
        msg.guild.channels.find('name', 'warns').send(`
      ØªÙ… Ø§Ø¹Ø·Ø§Ø¦Ùƒ ØªÙ†Ø¨ÙŠÙ‡ : ${msg.mentions.members.first()}
      Ù„Ø£Ù†Ùƒ Ù‚Ù…Øª Ø¨Ù…Ø§ ÙŠÙ„ÙŠ
      ${args.join(" ").split(msg.mentions.members.first()).slice(' ')}
      `)
      }
    }
})


client.on("roleCreate", role => {
  client.setTimeout(() => {
    role.guild.fetchAuditLogs({
        limit: 1,
        type: 30
      })
      .then(audit => {
        let exec = audit.entries.map(a => a.executor.username)
        try {
           let log = role.guild.channels.find('name', 'log');
          if (!log) return;
          let embed = new Discord.RichEmbed()
            .setColor('RANDOM')
            .setTitle('â• RoleCreated')
            .addField('Role Name', role.name, true)
            .addField('Role ID', role.id, true)
            .addField('By', exec, true)
            .setTimestamp()
          log.send(embed).catch(e => {
            console.log(e);
          });
        } catch (e) {
          console.log(e);
        }
      })
  }, 1000)
})
 client.on("roleDelete", role => {
  client.setTimeout(() => {
    role.guild.fetchAuditLogs({
        limit: 1,
        type: 30
      })
      .then(audit => {
        let exec = audit.entries.map(a => a.executor.username)
        try {
           let log = role.guild.channels.find('name', 'log');
          if (!log) return;
          let embed = new Discord.RichEmbed()
            .setColor('RANDOM')            
            .setTitle('âŒ RoleDeleted')
            .addField('Role Name:', role.name, true)
            .addField('Role ID:', role.id, true)
            .addField('By:', exec, true)
            .setTimestamp()
          log.send(embed).catch(e => {
            console.log(e);
          });
        } catch (e) {
          console.log(e);
        }
      })
  }, 1000)
})
   client.on("roleUpdate", (re,updated) => {
    client.setTimeout(() => {
      re.guild.fetchAuditLogs({
          limit: 1,
          type: 30
        })
        .then(audit => {
          let exec = audit.entries.map(a => a.executor.username)
          try {
  
            let log = re.guild.channels.find('name', 'log');
            if (!log) return;
            let embed = new Discord.RichEmbed()
              .setColor('BLACK')
              .setTitle("âœ  Role Name Updated")
              .addField("Old",`${re.name}`,true)
              .addField("New",`${updated.name}`,true )
              .addField("Role id",`${re.id}`,true )
              .addField('By', exec, true)
              .setTimestamp()
            log.send(embed).catch(e => {
              console.log(e);
            });
          } catch (e) {
            console.log(e);
          }
        })
    }, 1000)
  })
 client.on("channelDelete",  dc => {
  const channel = dc.guild.channels.find("name", "log")
  if(channel) {
  var embed = new Discord.RichEmbed()
  .setTitle(dc.guild.name)
  .setDescription(`***Channel Deleted Name : *** **${dc.name}** â¬…ï¸`)
  .setColor(`RANDOM`)
  .setTimestamp();
  channel.sendEmbed(embed)
  }
  });
   
  
client.on('messageUpdate', (message, newMessage) => {
    if (message.content === newMessage.content) return;
    if (!message || !message.id || !message.content || !message.guild || message.author.bot) return;
    const channel = message.guild.channels.find('name', 'log');
    if (!channel) return;
     let embed = new Discord.RichEmbed()
       .setAuthor(`${message.author.tag}`, message.author.avatarURL)
       .setColor('RANDOM')
       .setDescription(`âœ **Message Edited
Sender <@${message.author.id}>                                                                                                                         Edited In** <#${message.channel.id}>\n\nBefore Edited:\n \`${message.cleanContent}\`\n\nAfter Edited:\n \`${newMessage.cleanContent}\``)
       .setTimestamp();
     channel.send({embed:embed});
 });
 client.on('messageDelete', message => {
    if (!message || !message.id || !message.content || !message.guild || message.author.bot) return;
    const channel = message.guild.channels.find('name', 'log');
    if (!channel) return;
    
    let embed = new Discord.RichEmbed()
       .setAuthor(`${message.author.tag}`, message.author.avatarURL)
       .setColor('RANDOM')
       .setDescription(`ğŸ—‘ï¸ **Message Deleted**
**Sender <@${message.author.id}>                                                                                                                        Deleted In** <#${message.channel.id}>\n\n \`${message.cleanContent}\``)
       .setTimestamp();
     channel.send({embed:embed});
 });
 client.on('guildMemberAdd', member => {
    if (!member || !member.id || !member.guild) return;
    const guild = member.guild;
	
    const channel = member.guild.channels.find('name', 'log');
    if (!channel) return;
    let memberavatar = member.user.avatarURL
    const fromNow = moment(member.user.createdTimestamp).fromNow();
    const isNew = (new Date() - member.user.createdTimestamp) < 900000 ? 'ğŸ†•' : '';
    
    let embed = new Discord.RichEmbed()
       .setAuthor(`${member.user.tag}`, member.user.avatarURL)
	   .setThumbnail(memberavatar)
       .setColor('RANDOM')
       .setDescription(`ğŸ“¥ <@${member.user.id}> **Joined To The Server**\n\n`)
       .setTimestamp();
     channel.send({embed:embed});
});
 client.on('guildMemberRemove', member => {
    if (!member || !member.id || !member.guild) return;
    const guild = member.guild;
	
    const channel = member.guild.channels.find('name', 'log');
    if (!channel) return;
    let memberavatar = member.user.avatarURL
    const fromNow = moment(member.joinedTimestamp).fromNow();
    
    let embed = new Discord.RichEmbed()
       .setAuthor(`${member.user.tag}`, member.user.avatarURL)
	   .setThumbnail(memberavatar)
       .setColor('RAMDOM')
       .setDescription(`ğŸ“¤ <@${member.user.id}> **Leave From Server**\n\n`)
       .setTimestamp();
     channel.send({embed:embed});
});
 client.on('voiceStateUpdate', (oldM, newM) => {
  let m1 = oldM.serverMute;
  let m2 = newM.serverMute;
   let d1 = oldM.serverDeaf;
  let d2 = newM.serverDeaf;
   let ch = oldM.guild.channels.find('name', 'log')
  if(!ch) return;
     oldM.guild.fetchAuditLogs()
    .then(logs => {
       let user = logs.entries.first().executor
     if(m1 === false && m2 === true) {
       let embed = new Discord.RichEmbed()
       .setAuthor(`${newM.user.tag}`, newM.user.avatarURL)
       .setDescription(`${newM} has muted in server`)
       .setFooter(`By : ${user}`)
        ch.send(embed)
    }
    if(m1 === true && m2 === false) {
       let embed = new Discord.RichEmbed()
       .setAuthor(`${newM.user.tag}`, newM.user.avatarURL)
       .setDescription(`${newM} has unmuted in server`)
       .setFooter(`By : ${user}`)
       .setTimestamp()
        ch.send(embed)
    }
    if(d1 === false && d2 === true) {
       let embed = new Discord.RichEmbed()
       .setAuthor(`${newM.user.tag}`, newM.user.avatarURL)
       .setDescription(`${newM} has deafened in server`)
       .setFooter(`By : ${user}`)
       .setTimestamp()
        ch.send(embed)
    }
    if(d1 === true && d2 === false) {
       let embed = new Discord.RichEmbed()
       .setAuthor(`${newM.user.tag}`, newM.user.avatarURL)
       .setDescription(`${newM} has undeafened in server`)
       .setFooter(`By : ${user}`)
       .setTimestamp()
        ch.send(embed)
    }
  })
});
   client.on("guildBanAdd", (guild, member) => {
  client.setTimeout(() => {
    guild.fetchAuditLogs({
        limit: 1,
        type: 22
      })
      .then(audit => {
        let exec = audit.entries.map(a => a.executor.username);
        try {
          let log = guild.channels.find('name', 'log');
          if (!log) return;
          client.fetchUser(member.id).then(myUser => {
          let embed = new Discord.RichEmbed()
        .setAuthor(exec)
        .setThumbnail(myUser.avatarURL)
        .addField('- Banned User:',`**${myUser.username}**`,true)
        .addField('- Banned By:',`**${exec}**`,true)
        .setFooter(myUser.username,myUser.avatarURL)
            .setTimestamp();
          log.send(embed).catch(e => {
            console.log(e);
          });
          });
        } catch (e) {
          console.log(e);
        }
      });
  }, 1000);
});


client.login(process.env.BOT_TOKEN);
